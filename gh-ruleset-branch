#!/usr/bin/env bash

# shellcheck shell=bash

# Version
GHRB_VERSION="0.2.0"

# Global debug/verbose/dry-run flags (can be set via environment)
GHRB_DEBUG="${GHRB_DEBUG:-0}"
GHRB_VERBOSE="${GHRB_VERBOSE:-0}"
GHRB_DRY_RUN="${GHRB_DRY_RUN:-0}"

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_ERROR=1
readonly EXIT_USAGE=2

######################################################################
#<
#
# Function: _error()
#
#  Args:
#	message - error message to print
#	exit_code - optional exit code (default: EXIT_ERROR)
#>
######################################################################
_error() {
  local message="$1"
  local exit_code="${2:-$EXIT_ERROR}"

  echo >&2 "Error: $message"
  exit "$exit_code"
}

######################################################################
#<
#
# Function: _require_arg()
#
#  Args:
#	name - argument name for error message
#	value - argument value to check
#>
######################################################################
_require_arg() {
  local name="$1"
  local value="$2"

  if [ -z "$value" ]; then
    _error "Missing required argument: $name" "$EXIT_USAGE"
  fi
}

######################################################################
#<
#
# Function: _validate_ruleset_exists()
#
#  Args:
#	name - ruleset name
#	id - ruleset id (may be empty)
#>
######################################################################
_validate_ruleset_exists() {
  local name="$1"
  local id="$2"

  if [ -z "$id" ]; then
    _error "Ruleset not found: '$name'. Use 'list' to see available rulesets."
  fi
}

######################################################################
#<
#
# Function: _dry_run()
#
#  Args:
#	action - description of what would be done
#
#  Environment:	 GHRB_DRY_RUN
#>
######################################################################
_dry_run() {
  if [ "$GHRB_DRY_RUN" = "1" ]; then
    echo "[DRY-RUN] $*"
    return 0
  fi
  return 1
}

######################################################################
#<
#
# Function: _version()
#
#  Environment:	 GHRB_VERSION
#>
######################################################################
_version() {
  echo "gh-ruleset-branch version $GHRB_VERSION"
  exit 0
}

######################################################################
#<
#
# Function: _debug()
#
#  Args:
#	message - debug message to print
#
#  Environment:	 GHRB_DEBUG
#>
######################################################################
_debug() {
  if [ "$GHRB_DEBUG" = "1" ]; then
    echo >&2 "[DEBUG] $*"
  fi
}

######################################################################
#<
#
# Function: _verbose()
#
#  Args:
#	message - verbose message to print
#
#  Environment:	 GHRB_VERBOSE
#>
######################################################################
_verbose() {
  if [ "$GHRB_VERBOSE" = "1" ]; then
    echo >&2 "[VERBOSE] $*"
  fi
}

######################################################################
#<
#
# Function: p6_usage()
#
#  Args:
#
#  Environment:	 EOF LC_ALL NAME OPTIND RULE WHAT
#>
######################################################################
p6_usage() {
  local rc="${1:-$EXIT_SUCCESS}"
  local msg="${2:-}"

  if [ -n "$msg" ]; then
    echo >&2 "Error: $msg"
  fi
  cat <<EOF
Usage:
  gh-ruleset-branch.zsh [options] <cmd> [<args>...]

Commands:
  activate <name>                Activate a branch ruleset
  create <name>                  Create a branch ruleset
  deactivate <name>              Deactivate a branch ruleset
  delete <name>                  Delete a branch ruleset
  export <name>                  Export a branch ruleset as JSON
  import                         Import a branch ruleset from JSON (stdin)
  list                           List all branch rulesets
  show <name>                    Show a branch ruleset
  update <name> <what>=<value>   Update a branch ruleset

Options:
  -h, --help                     Show this help message
  --version                      Show version information
  --json                         Output raw JSON (for list command)
  --dry-run                      Show what would be done without making changes
  --debug                        Enable debug output (or set GHRB_DEBUG=1)
  --verbose                      Enable verbose API logging (or set GHRB_VERBOSE=1)

Examples:
  gh-ruleset-branch.zsh list
  gh-ruleset-branch.zsh list --json
  gh-ruleset-branch.zsh activate "My Ruleset"
  gh-ruleset-branch.zsh create "My Ruleset"
  gh-ruleset-branch.zsh deactivate "My Ruleset"
  gh-ruleset-branch.zsh delete "My Rules"
  gh-ruleset-branch.zsh show "My Ruleset"
  gh-ruleset-branch.zsh export "My Ruleset" > ruleset.json
  gh-ruleset-branch.zsh import < ruleset.json
  gh-ruleset-branch.zsh update "My Ruleset" required_signatures=enabled
  gh-ruleset-branch.zsh update "My Ruleset" required_status_checks=disabled merge_method=squash required_approving_review_count=2
  gh-ruleset-branch.zsh update "My Ruleset" pull_request.required_approving_review_count=2 pull_request.dismiss_stale_reviews_on_push=true
  gh-ruleset-branch.zsh update "My Ruleset" conditions.include="~DEFAULT_BRANCH"
EOF
  exit "$rc"
}


######################################################################
#<
#
# Function: p6main()
#
#  Args:
#>
######################################################################
p6main() {
  shift 0

  # sanitize env
  LC_ALL=C

  # parse global options (--debug, --verbose, --dry-run, --version, --help) before getopts
  local args=()
  while [ $# -gt 0 ]; do
    case "$1" in
      --debug) GHRB_DEBUG=1 ;;
      --verbose) GHRB_VERBOSE=1 ;;
      --dry-run) GHRB_DRY_RUN=1 ;;
      --version) _version ;;
      --help) p6_usage 0 ;;
      *) args+=("$1") ;;
    esac
    shift
  done
  set -- "${args[@]}"

  _debug "Starting gh-ruleset-branch"
  _debug "Arguments: $*"

  # parse options
  local flag
  while getopts "h" flag; do
    case $flag in
    h) p6_usage "$EXIT_SUCCESS" ;;
    *) p6_usage "$EXIT_USAGE" "Invalid flag: -$OPTARG" ;;
    esac
  done
  shift $((OPTIND - 1))

  # grab command
  local cmd="${1:-}"

  if [ -z "$cmd" ]; then
    p6_usage "$EXIT_USAGE" "No command specified"
  fi

  shift 1

  _debug "Command: $cmd"

  # security 101: only allow valid commands
  case $cmd in
  help) p6_usage "$EXIT_SUCCESS" ;;
  activate) ;;
  create) ;;
  deactivate) ;;
  delete) ;;
  export) ;;
  import) ;;
  list) ;;
  show) ;;
  update) ;;
  *) p6_usage "$EXIT_USAGE" "Unknown command: $cmd" ;;
  esac

  # exit if any cli errors w/ >0 return code
  # the commands can still disable locally if needed
  set -e
  p6_cmd_"${cmd}" "$@"
  set +e

  return 0
}

_jq_update() {
  local json_file="$1"
  local what="$2"
  local update="$3"
  local rule_fn="$4"

  if [ "$update" = "enabled" ]; then
    local rule="$($rule_fn)"
    jq --argjson RULE "$rule" '.rules += [$RULE] | .rules |= unique_by(.type)' < "$json_file"
  else
    jq --arg WHAT "$what" '.rules |= map(select(.type != $WHAT))' < "$json_file"
  fi
}

#############################################################################
_jq_toggle_rule() {
  local json_file="$1"
  local rule="$2"
  local state="$3"

  local tmp="${json_file}.new"
  rm -f "$tmp"

  if [ "$state" = "enabled" ]; then
    local rule_json
    rule_json="{ \"type\": \"${rule}\" }"

    # Pass JSON safely as string, parse inside jq using fromjson
    jq --arg R "$rule" --arg RULE "$rule_json" \
      '.rules = ((.rules // []) + [($RULE | fromjson)] | unique_by(.type))' \
      < "$json_file" > "$tmp"
  else
    jq --arg R "$rule" \
      '.rules = ((.rules // []) | map(select(.type != $R)))' \
      < "$json_file" > "$tmp"
  fi

  mv "$tmp" "$json_file"
}

_jq_set_rule_params() {
  local json_file="$1"
  local rule="$2"
  shift 2

  local tmp="${json_file}.new"

  # ensure skeleton exists
  jq --arg R "$rule" '
    (
      .rules = (.rules // [])
      | if any(.rules[]; .type == $R)
        then .
        else .rules += [{"type": $R, "parameters": {}}]
        end
    )
  ' < "$json_file" > "$tmp"
  mv "$tmp" "$json_file"

  # apply each k=v
  local kv
  for kv in "$@"; do
    local k="${kv%%=*}"
    local v="${kv#*=}"

    if [[ "$k" == "allowed_merge_methods" ]]; then
      jq --arg R "$rule" --arg K "$k" --argjson ARR "$(jq -nc --arg v "$v" '[ $v ]')" '
        .rules |= map(if .type==$R
                      then .parameters[$K]=$ARR
                      else . end)
      ' < "$json_file" > "$tmp"

    elif [[ "$v" =~ ^[0-9]+$ || "$v" == "true" || "$v" == "false" ]]; then
      jq --arg R "$rule" --arg K "$k" --argjson V "$v" '
        .rules |= map(if .type==$R
                      then (.parameters = (.parameters // {})) | (.parameters[$K]=$V)
                      else . end)
      ' < "$json_file" > "$tmp"

    else
      jq --arg R "$rule" --arg K "$k" --arg V "$v" '
        .rules |= map(if .type==$R
                      then (.parameters = (.parameters // {})) | (.parameters[$K]=$V)
                      else . end)
      ' < "$json_file" > "$tmp"
    fi

    mv "$tmp" "$json_file"
  done
}

_jq_set_conditions() {
  local json_file="$1"
  local include="$2"
  local exclude="$3"

  local tmp="${json_file}.new"

  jq --argjson INCLUDE "$(jq -nc --arg v "$include" '[ $v | select(length>0) ]')" \
     --argjson EXCLUDE "$(jq -nc --arg v "$exclude" '[ $v | select(length>0) ]')" '
    .conditions.ref_name = {
      include: (if $INCLUDE|length>0 then $INCLUDE else [] end),
      exclude: (if $EXCLUDE|length>0 then $EXCLUDE else [] end)
    }
  ' < "$json_file" > "$tmp"
  mv "$tmp" "$json_file"
}

_json_meta() {
  local name="$1"
  local id="$2"

  local id_json_clause
  if [ -n "$id" ]; then
    id_json_clause="\"id\": ${id},"
  else
    id_json_clause=""
  fi

  cat <<EOF
{
  ${id_json_clause}
  "name":"${name}",
  "target":"branch",
  "enforcement":"active"
}
EOF

  return
}

_gh() {
  _verbose "API request: gh api $*"

  local result
  result=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "$@" 2>&1)
  local exit_code=$?

  _verbose "API response (exit $exit_code): ${result:0:500}..."

  if [ $exit_code -ne 0 ]; then
    echo "$result" >&2
    return $exit_code
  fi

  echo "$result"
}

_p6_ruleset_id_by_name() {
  local name="$1"

  _debug "Looking up ruleset ID for name: $name"
  local id
  id=$(_gh repos/:owner/:repo/rulesets | jq -r --arg NAME "$name" '.[] | select(.name==$NAME) | .id' | head -1)
  _debug "Found ruleset ID: $id"
  echo "$id"
}

######################################################################
#<
#
# Function: p6_cmd_list(...)
#
#  Args:
#	... - optional --json flag
#
#  Environment:	 GET
#>
######################################################################
p6_cmd_list() {
  local json_output=false

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --json) json_output=true ;;
      *) ;;
    esac
    shift
  done

  local result
  result=$(_gh --method GET repos/:owner/:repo/rulesets)

  if [ "$json_output" = "true" ]; then
    echo "$result"
  else
    # Table format output
    echo "$result" | jq -r '
      ["ID", "NAME", "ENFORCEMENT", "TARGET"],
      (.[] | [.id, .name, .enforcement, .target]) | @tsv
    ' | column -t -s $'\t'
  fi
}

######################################################################
#<
#
# Function: p6_cmd_activate(name)
#
#  Args:
#	name -
#
#  Environment:	 PUT
#>
######################################################################
p6_cmd_activate() {
  local name="$1"

  _require_arg "name" "$name"

  local id
  id="$(_p6_ruleset_id_by_name "$name")"
  _validate_ruleset_exists "$name" "$id"

  if _dry_run "Would activate ruleset '$name' (id: $id)"; then
    return 0
  fi

  _gh --method PUT "repos/:owner/:repo/rulesets/${id}" -f enforcement='active' 2>&1 | jq '{id,name,enforcement}'
}

######################################################################
#<
#
# Function: p6_cmd_deactivate(name)
#
#  Args:
#	name -
#
#  Environment:	 PUT
#>
######################################################################
p6_cmd_deactivate() {
  local name="$1"

  _require_arg "name" "$name"

  local id
  id="$(_p6_ruleset_id_by_name "$name")"
  _validate_ruleset_exists "$name" "$id"

  if _dry_run "Would deactivate ruleset '$name' (id: $id)"; then
    return 0
  fi

  _gh --method PUT "repos/:owner/:repo/rulesets/${id}" -f enforcement='disabled' 2>&1 | jq '{id,name,enforcement}'
}

######################################################################
#<
#
# Function: p6_cmd_create(name)
#
#  Args:
#	name -
#
#  Environment:	 POST
#>
######################################################################
p6_cmd_create() {
  local name="$1"

  _require_arg "name" "$name"

  if _dry_run "Would create ruleset '$name' with default settings"; then
    _json_meta "$name"
    return 0
  fi

  local jf="/tmp/jf-create.json"
  _json_meta "$name" > "$jf"
  _gh --method POST repos/:owner/:repo/rulesets --input - <"$jf" 2>&1
  rm -f "$jf"
}

######################################################################
#<
#
# Function: p6_cmd_delete(name)
#
#  Args:
#	name -
#
#  Environment:	 DELETE
#>
######################################################################
p6_cmd_delete() {
  local name="$1"

  _require_arg "name" "$name"

  local id
  id="$(_p6_ruleset_id_by_name "$name")"
  _validate_ruleset_exists "$name" "$id"

  if _dry_run "Would delete ruleset '$name' (id: $id)"; then
    return 0
  fi

  _gh --method DELETE "repos/:owner/:repo/rulesets/${id}"
}

######################################################################
#<
#
# Function: p6_cmd_show(name)
#
#  Args:
#	name -
#
#  Environment:	 GET
#>
######################################################################
p6_cmd_show() {
  local name="$1"

  _require_arg "name" "$name"

  local id
  id="$(_p6_ruleset_id_by_name "$name")"
  _validate_ruleset_exists "$name" "$id"

  _gh --method GET "repos/:owner/:repo/rulesets/${id}"
}

######################################################################
#<
#
# Function: p6_cmd_export(name)
#
#  Args:
#	name - ruleset name
#
#  Environment:	 GET
#>
######################################################################
p6_cmd_export() {
  local name="$1"

  _require_arg "name" "$name"

  local id
  id="$(_p6_ruleset_id_by_name "$name")"
  _validate_ruleset_exists "$name" "$id"

  _debug "Exporting ruleset '$name' (id: $id)"

  # Export ruleset without id field (id is repository-specific)
  _gh --method GET "repos/:owner/:repo/rulesets/${id}" | \
    jq 'del(.id) | del(.source) | del(.source_type) | del(.node_id) | del(.created_at) | del(.updated_at) | del(._links)'
}

######################################################################
#<
#
# Function: p6_cmd_import()
#
#  Args:
#	(reads from stdin)
#
#  Environment:	 POST
#>
######################################################################
p6_cmd_import() {
  local json_input

  # Read JSON from stdin
  if ! json_input=$(cat); then
    _error "Failed to read JSON from stdin"
  fi

  # Validate JSON
  if ! echo "$json_input" | jq empty 2>/dev/null; then
    _error "Invalid JSON input"
  fi

  # Extract name for logging
  local name
  name=$(echo "$json_input" | jq -r '.name // "unnamed"')

  _debug "Importing ruleset '$name'"

  if _dry_run "Would import ruleset '$name' from JSON"; then
    echo "Proposed configuration:"
    echo "$json_input" | jq .
    return 0
  fi

  # Create the ruleset
  echo "$json_input" | _gh --method POST repos/:owner/:repo/rulesets --input -
}

######################################################################
#<
#
# Function: p6_cmd_update(name, ...)
#
#  Args:
#	name -
#	... - 
#
#  Environment:	 GET PARAMS PUT
#>
######################################################################
p6_cmd_update() {
  local name="$1"
  shift 1

  _require_arg "name" "$name"

  local id
  id="$(_p6_ruleset_id_by_name "$name")"
  _validate_ruleset_exists "$name" "$id"

  local jf="/tmp/jq.json"
  _gh --method GET "repos/:owner/:repo/rulesets/${id}" | jq '{id,name,enforcement,target,conditions,rules:(.rules//[])}' > "$jf"

  # parse args: toggles (rule=enabled|disabled) and params (rule.key=value)
  local arg
  local rule
  local key
  local val

  # collect per-rule params @PARAMS
  declare -A PARAMS
  while [ $# -gt 0 ]; do
    arg="$1";
    shift 1

    case "$arg" in
      conditions.include=*)
        include="${arg#*=}"
        ;;
      conditions.exclude=*)
        exclude="${arg#*=}"
        ;;
      *)
        rule="${arg%%=*}"
        val="${arg#*=}"

        if [[ "$rule" == *.* ]]; then
          rule="${rule%%.*}"
          key="${arg#*.}"
          key="${key%%=*}"
          PARAMS["$rule"]+="${PARAMS[$rule]:+ }$key=$val"
        else
          _jq_toggle_rule "$jf" "$rule" "$val"
        fi
        ;;
      esac
  done

  # apply condition update if set
  if [ -n "${include}${exclude}" ]; then
    _jq_set_conditions "$jf" "$include" "$exclude"
  fi

  # apply param sets
  for rule in "${!PARAMS[@]}"; do
    read -r -a kvs <<< "${PARAMS[$rule]}"
    _jq_set_rule_params "$jf" "$rule" "${kvs[@]}"
  done

  unset PARAMS

  if _dry_run "Would update ruleset '$name' (id: $id) with changes:"; then
    echo "Proposed configuration:"
    jq '{conditions,rules}' < "$jf"
    rm -f "$jf"
    return 0
  fi

  _gh --method PUT "repos/:owner/:repo/rulesets/${id}" --input - < "$jf" | jq '{conditions,rules}'
  rm -f "$jf"
}

p6main "$@"
